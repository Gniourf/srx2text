#!/usr/bin/perl

# This script converts an srx (sparql-results+xml) file into a (text) table

use v5.014;
use utf8;
use strict;
use autodie;
use warnings qw< FATAL utf8 >;
use open qw< :std :utf8 >;
use charnames qw< :full >;
use feature qw< unicode_strings >;

use XML::LibXML;

use Pod::Usage;
use Getopt::Long;
use Term::ReadKey;
use Encode;

use Data::Dumper;
#

#
my %prefixes=(
   dc => "http://purl.org/dc/elements/1.1/",
   dcterms => "http://purl.org/dc/terms/",
   eor => "http://dublincore.org/2000/03/13/eor#",
   foaf => "http://xmlns.com/foaf/0.1/",
   owl => "http://www.w3.org/2002/07/owl#",
   rdf => "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
   rdfs => "http://www.w3.org/2000/01/rdf-schema#",
   serql => "http://www.openrdf.org/schema/serql#",
   skos => "http://www.w3.org/2004/02/skos/core#",
   vann => "http://purl.org/vocab/vann/",
   void => "http://rdfs.org/ns/void#",
   xsd => "http://www.w3.org/2001/XMLSchema#",
);
#

my $is_in_terminal=(-t STDOUT);
my $help=0;
my $version=0;
my $fitterminal=$is_in_terminal;
my $imposed_width;
GetOptions(
   'help|h|?' => \$help,
   'version|v' => \$version,
   'fit-to-terminal!' => \$fitterminal, # Used if you pipe the output, then $is_in_terminal will be false, yet you'll probably want to fit to terminal's width
   'width|w=i' => \$imposed_width,
) or pod2usage(1);

pod2usage(-exit => 0, -verbose => 2, -noperldoc => 1) if $help;
if($version) {
   print "srx2text 0.1.3\n";
   exit(0);
}

my $fh;
if(@ARGV) {
   my $file=shift;
   open($fh ,'<', $file); #$file || die "can't open file or standard input for reading: $!";
}
else {
   $fh=\*STDIN;
}
binmode $fh;

#
sub format_uri {
   my $uri=shift;
   my $found;
   while(my ($prefix,$prefix_uri)=each %prefixes) {
      if(index($uri,$prefix_uri)==0) {
         $uri=$prefix.":".(substr $uri,(length $prefix_uri));
         $uri="a" if($uri eq "rdf:type");
         $found=1;
      }
   }
   $uri="<".$uri.">" unless($found);
   return $uri;
}

my $doc=XML::LibXML->load_xml(IO=>$fh);

my $sparql_node=$doc->firstChild;
die "First node isn't sparql" unless $sparql_node->nodeName eq "sparql";

my @sparql_children=$sparql_node->nonBlankChildNodes;
my $head_node=$sparql_children[0];
die "head node not found in first position" unless $head_node->nodeName eq "head";
#
my $results_node=$sparql_children[1];
my @results_children=$results_node->nonBlankChildNodes;
my $result_type=$results_node->nodeName;

my @variables;
my @rows;
if($result_type eq "results") {
   # Get variable nodes inside head
   my @head_children=@{$head_node->nonBlankChildNodes};
   for my $v (@head_children) {
      die "In head: not a variable node" unless $v->nodeName eq "variable";
      die "In head: variable node has no name attribute" unless $v->hasAttribute("name");
      push(@variables,$v->getAttribute("name"));
   }
   # Get result node inside results
   for my $r (@results_children) {
      die "In results: not a result node" unless $r->nodeName eq "result";
      my %hrow;
      for my $b ($r->nonBlankChildNodes) {
         die "In result: not a binding node" unless $b->nodeName eq "binding";
         die "In result: binding node doesn't have a name attribute" unless $b->hasAttribute("name");
         my $variable=$b->getAttribute("name");
         my @b_children=$b->nonBlankChildNodes;
         die "binding node has ".@b_children." children! (should only have 1)" unless @b_children==1;
         my $uri=$b_children[0];
         my $value;
         given($uri->nodeName) {
            when (/^uri$/) { $value=format_uri($uri->textContent); }
            when (/^literal$/) { $value=$uri->textContent; }
            default { die "In binding: expecting uri or literal node. Found ".$uri->nodeName."\." unless $uri->nodeName eq "uri"; }
         }
         $hrow{$variable}=$value;
      }
      my @row;
      for my $var (@variables) {
         my $topush;
         if(defined $hrow{$var}) { $topush=$hrow{$var}; }
         else { $topush=''; }
         push(@row,$topush);
      }
      push(@rows,\@row);
   }
}
elsif($result_type eq "boolean") {
   my $banswer=$results_children[0]->textContent;
   die "Bad boolean: $banswer" unless grep { $_ eq $banswer } ( "true", "false" );
   print $banswer."\n";
   exit(0);
}
else {
   die "results node not found in second position (found $result_type node)";
}

#################
# Print results #
#################

if (@rows==0) {
   print "No results\n";
   exit(0);
}

#################
# Format output #
#################

# Get max length of each column
my @colwidth=map { 1+length; } @variables;
for my $r (@rows) {
   for(my $i=0;$i<@{$r};++$i) {
      my $l=length($r->[$i]);
      $colwidth[$i]=$l if $colwidth[$i]<$l;
   }
}

my $nbcols=@variables;
# Get the total (natural) width of the table:
my $totalwidth=0;
map { $totalwidth += $_ } @colwidth;
my $table_natural_width=$totalwidth+2+3*($nbcols-1)+2;

# Get max width of wanted output:
my $wanted_max_width;
my @term_size=GetTerminalSize();
if(@term_size && $fitterminal) {
   $wanted_max_width=$term_size[0];
}
if($imposed_width) {
   if($wanted_max_width) {
      $wanted_max_width=$imposed_width if $imposed_width<$wanted_max_width;
   }
   else {
      $wanted_max_width=$imposed_width;
   }
}

sub get_good_bad {
   use integer;
   my ($w,$a,$good_pary,$bad_pary,$n_pary)=@_;
   my @new_good=grep { $n_pary->[$_]<=$a } @{$bad_pary};
   my @new_bad=grep { $n_pary->[$_]>$a } @{$bad_pary};
   my @r=@{$n_pary};
   for my $i (@new_good) { $r[$i]=$n_pary->[$i]; }
   if(@new_bad==0 || @new_bad==@{$bad_pary}) {
      my $wbad=0;
      map { $wbad+=$n_pary->[$_] } @new_bad;
      die "Can't fit table" unless($wbad);
      for my $i (@new_bad) {
         $r[$i]=($w*$n_pary->[$i])/$wbad;
      }
      return \@r;
   }
   else {
      my $width_new_good=0;
      map { $width_new_good += $n_pary->[$_] } @new_good;
      my $new_w=$w-$width_new_good;
      my $new_a=$new_w/@new_bad;
      return get_good_bad($new_w,$new_a,\@new_good,\@new_bad,\@r);
   }
}

sub min2 { $_[$_[0]>$_[1]]; }

sub format_row {
   my($format,$w_ary,$text_ary)=@_;
   my @cols;
   my $maxnbrows=0;
   for(my $i=0;$i<@{$text_ary};++$i) {
      my @subcol=unpack("(a$w_ary->[$i])*",$text_ary->[$i]);
      push(@cols,\@subcol);
      $maxnbrows=@subcol if $maxnbrows<@subcol;
   }
   my @rows;
   for(my $i=0;$i<$maxnbrows;++$i) {
      my @subrow;
      for my $c (@cols) {
         if(defined $c->[$i]) {
            push(@subrow,$c->[$i]);
         }
         else {
            push(@subrow,"");
         }
      }
      push(@rows,\@subrow);
   }
   map { printf "$format\n",@{$_} } @rows;
}

my @colwidth_wrapped;
{
   use integer;
   if($wanted_max_width && $table_natural_width>$wanted_max_width) {
      # Truncate large columns to something reasonable
      my @colwidth_trunc=map { min2($_,$wanted_max_width/2) } @colwidth;
      #
      my $w=$wanted_max_width-(2+3*($nbcols-1)+2);
      @colwidth_wrapped=@{get_good_bad($w,$w/$nbcols,[],[0..($nbcols-1)],\@colwidth_trunc)};
   }
   else {
      @colwidth_wrapped=@colwidth;
   }
}

# Get the total (wrapped) width of the table:
$totalwidth=0;
map { $totalwidth += $_ } @colwidth_wrapped;
my $table_wrapped_width=$totalwidth+2+3*($nbcols-1)+2;

# Rules
my $hor_rule_upper="┌─".join("─┬─",map { "─"x$_ } @colwidth_wrapped)."─┐";
my $hor_rule_middle="├─".join("─┼─",map { "─"x$_ } @colwidth_wrapped)."─┤";
my $hor_rule_lower="└─".join("─┴─",map { "─"x$_ } @colwidth_wrapped)."─┘";
my $format="│ ".join(' │ ',map { "%-".$_."s" } @colwidth_wrapped)." │";

print $hor_rule_upper."\n";
my @hvariables=map { "?".$_ } @variables;
format_row($format,\@colwidth_wrapped,\@hvariables);
print $hor_rule_middle."\n";
map { format_row($format,\@colwidth_wrapped,$_) } @rows;
print $hor_rule_lower."\n";
# Total:
print "\n".@rows." results\n";

# vim: set filetype=perl :

__END__

=pod

=encoding utf-8

=head1 NAME

srx2text

=head1 USAGE

srx2text [FILENAME]

=head1 SYNOPSIS

Reads FILENAME or standard input, that must be a well-formed srx file
(sparql-results+xml), see L<http://www.w3.org/TR/rdf-sparql-query/>,
and outputs a table in text format.

The common prefixes are used.

=head1 OPTIONS

=over 4

=item -h, -?, --help

Show this help and exit

=item -v, --version

Show version and exit

=item --fit-to-terminal, --nofit-to-terminal

Used if you pipe the output, you'll probably want to fit to terminal's width.

=item --width W, -w W

Impose width to be W

=back

=head1 LICENSE

A very permissive one!

=head1 VERSION

0.1.3

=head1 AUTHOR

Gniourf - L<gniourfgniourf@gmail.com>

=cut

