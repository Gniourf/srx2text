#!/usr/bin/perl

# This script converts an srx (sparql-results+xml) file into a (text) table

use v5.014;
use utf8;
use strict;
use warnings qw< FATAL utf8 >;
use open qw< :std :utf8 >;
use charnames qw< :full >;
use feature qw< unicode_strings >;

use XML::LibXML;

use Pod::Usage;
use Getopt::Long;
use Term::ReadKey;
use Encode;

use URI;

use Data::Dumper;

#
my %prefixes=(
   dc => "http://purl.org/dc/elements/1.1/",
   dcterms => "http://purl.org/dc/terms/",
   eor => "http://dublincore.org/2000/03/13/eor#",
   foaf => "http://xmlns.com/foaf/0.1/",
   owl => "http://www.w3.org/2002/07/owl#",
   rdf => "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
   rdfs => "http://www.w3.org/2000/01/rdf-schema#",
   serql => "http://www.openrdf.org/schema/serql#",
   skos => "http://www.w3.org/2004/02/skos/core#",
   vann => "http://purl.org/vocab/vann/",
   void => "http://rdfs.org/ns/void#",
   xsd => "http://www.w3.org/2001/XMLSchema#",
);
#

my $is_in_terminal=(-t STDOUT);
my $help;
my $version;
my $fitterminal=$is_in_terminal;
my $imposed_width;
my $show_iri=1;
GetOptions(
   'help|h|?' => \$help,
   'version|v' => \$version,
   'fit-to-terminal!' => \$fitterminal,
   'width|w=i' => \$imposed_width,
   'iri!' => \$show_iri,
) or pod2usage(1);

pod2usage(-exit => 0, -verbose => 2, -noperldoc => 1) if $help;
if($version) {
   print "srx2text 0.1.12\n";
   exit(0);
}

if(@ARGV) {
   my $i;
   map {
      if(open(my $fh ,'<', $_)) {
         binmode $fh;
         print "File $_\n";
         parse_srx($fh);
         ++$i;
         print "\n" unless($i==@ARGV);
      }
      else {
         warn "Can't open file `$_' for reading: $!";
      }
   } @ARGV;
}
else {
   my $fh=\*STDIN;
   binmode $fh;
   parse_srx($fh);
}

#
sub format_uri {
   my $uri=shift;
   my $found;
   keys %prefixes; # Explicitely reset the each iterator
   while(my ($prefix,$prefix_uri)=each %prefixes) {
      if(index($uri,$prefix_uri)==0) {
         $uri=$prefix.":".(substr $uri,(length $prefix_uri));
         $found=1;
         last;
      }
   }
   if($found) {
      $uri="a" if($uri eq "rdf:type");
   }
   else {
      $uri=URI->new($uri)->as_iri if $show_iri;
      $uri="<".$uri.">";
   }
   return $uri;
}

sub parse_srx {
   my $fh=shift;
   my $doc=XML::LibXML->load_xml(IO=>$fh);

   my $sparql_node=$doc->firstChild;
   die "First node isn't sparql (found ".$sparql_node->nodeName.")" unless $sparql_node->nodeName eq "sparql";
   warn "sparql node doesn't have attribute xmlns with value http://www.w3.org/2005/sparql-results#"
      unless($sparql_node->getAttribute("xmlns") eq "http://www.w3.org/2005/sparql-results#");

   my $sparql_children=\@{$sparql_node->nonBlankChildNodes};
   my $head_node=$sparql_children->[0];
   die "head node not found in first position" unless $head_node->nodeName eq "head";
   #
   my $results_node=$sparql_children->[1];

   my @variables;
   my @rows;
   given($results_node->nodeName) {
      when($_ eq "results") {
         # Get variable and link nodes inside head
         my $inlink;
         for my $v ($head_node->nonBlankChildNodes) {
            given($v->nodeName) {
               when($_ eq "variable") { die "variable node after link node" if $inlink; push(@variables,$v->getAttribute("name")); }
               when($_ eq "link") { $inlink=1; }
               default { die "In head: bad node ".$v->nodeName.". Expecting variable or link node"; }
            }
         }
         # Get result node inside results
         for my $r ($results_node->nonBlankChildNodes) {
            die "In results: not a result node" unless $r->nodeName eq "result";
            my %hrow;
            for my $b ($r->nonBlankChildNodes) {
               die "In result: not a binding node" unless $b->nodeName eq "binding";
               my $variable=$b->getAttribute("name") || die "In result: binding node doesn't have a name attribute";
               my $b_children=\@{$b->nonBlankChildNodes};
               die "binding node has ".@{$b_children}." children! (should only have 1)" unless @${b_children}==1;
               my $uri=$b_children->[0];
               my $value;
               given($uri->nodeName) {
                  when ($_ eq "uri") { $value=format_uri($uri->textContent); }
                  when ($_ eq "literal") { $value=$uri->textContent; }
                  when ($_ eq "bnode") { $value="_:".$uri->textContent; }
                  default { die "In binding: expecting uri, literal or bnode node. Found ".$uri->nodeName."\."; }
               }
               $hrow{$variable}=$value;
            }
            my @row=map { defined $hrow{$_}?$hrow{$_}:'' } @variables;
            push(@rows,\@row);
         }
      }
      when($_ eq "boolean") {
         my $banswer=($results_node->nonBlankChildNodes)[0]->textContent;
         die "Bad boolean: $banswer" unless grep { $_ eq $banswer } ( "true", "false" );
         print $banswer."\n";
         exit(0);
      }
      default { die "Not a valid node: $_ at this position"; }
   }
   print_table(\@variables,\@rows);
}

################
# Table format #
################

sub get_good_bad {
   use integer;
   my ($w,$good_pary,$bad_pary,$n_pary)=@_;
   my $a=$w/@{$bad_pary};
   my @new_good=grep { $n_pary->[$_]<=$a } @{$bad_pary};
   my @new_bad=grep { $n_pary->[$_]>$a } @{$bad_pary};
   my @r=@{$n_pary};
   map { $r[$_]=$n_pary->[$_] } @new_good;
   if(!@new_bad) {
      return \@r;
   }
   elsif(@new_bad==@{$bad_pary}) {
      my $wbad=0;
      map { $wbad+=$n_pary->[$_] } @new_bad;
      die "Can't fit table" unless($wbad);
      map { $r[$_]=($w*$n_pary->[$_])/$wbad } @new_bad;
      return \@r;
   }
   else {
      my $width_new_good=0;
      map { $width_new_good += $n_pary->[$_] } @new_good;
      my $new_w=$w-$width_new_good;
      return get_good_bad($new_w,\@new_good,\@new_bad,\@r);
   }
}

sub format_row {
   my($format,$w_ary,$text_ary)=@_;
   my @cols;
   my $maxnbrows=0;
   for(my $i=0;$i<@{$text_ary};++$i) {
      my @subcol=unpack("(a$w_ary->[$i])*",$text_ary->[$i]);
      push(@cols,\@subcol);
      $maxnbrows=@subcol if $maxnbrows<@subcol;
   }
   my @rows;
   for(my $i=0;$i<$maxnbrows;++$i) {
      my @subrow;
      map { push(@subrow,(defined $_->[$i])?$_->[$i]:"") } @cols;
      push(@rows,\@subrow);
   }
   map { printf "$format\n",@{$_} } @rows;
}

sub print_table {
   my ($variables_pary,$rows_pary)=@_;
   if (@{$rows_pary}==0) {
      print "No results\n";
      return 1;
   }
   
   # Get max length of each column
   # The 1+ accounts for the '?' symbol prepended to variable name
   my @colwidth=map { 1+length; } @{$variables_pary};
   for my $r (@{$rows_pary}) {
      my $i=0;
      @colwidth=map { my $l=length $r->[$i++]; $_<$l?$l:$_ } @colwidth;
   }
   
   my $nbcols=@{$variables_pary};
   # Get the total (natural) width of the table:
   my $totalwidth=0;
   map { $totalwidth += $_ } @colwidth;
   my $table_natural_width=$totalwidth+2+3*($nbcols-1)+2;
   
   # Get max width of wanted output:
   my $wanted_max_width;
   my @term_size=GetTerminalSize();
   
   $wanted_max_width=$term_size[0] if(@term_size && $fitterminal);
   
   if($imposed_width) {
      if($wanted_max_width) {
         $wanted_max_width=$imposed_width if $imposed_width<$wanted_max_width;
      }
      else {
         $wanted_max_width=$imposed_width;
      }
   }
   
   my @colwidth_wrapped;
   if($wanted_max_width && $table_natural_width>$wanted_max_width) {
      my @colwidth_trunc=map { $_>$wanted_max_width?$wanted_max_width:$_ } @colwidth;
      my $w=$wanted_max_width-(2+3*($nbcols-1)+2);
      @colwidth_wrapped=@{get_good_bad($w,[],[0..($nbcols-1)],\@colwidth_trunc)};
   }
   else {
      @colwidth_wrapped=@colwidth;
   }
   
   # Get the total (wrapped) width of the table:
   $totalwidth=0;
   map { $totalwidth += $_ } @colwidth_wrapped;
   my $table_wrapped_width=$totalwidth+2+3*($nbcols-1)+2;
   
   # Rules
   my $hor_rule_upper="┌─".join("─┬─",map { "─"x$_ } @colwidth_wrapped)."─┐";
   my $hor_rule_middle="├─".join("─┼─",map { "─"x$_ } @colwidth_wrapped)."─┤";
   my $hor_rule_lower="└─".join("─┴─",map { "─"x$_ } @colwidth_wrapped)."─┘";
   my $format="│ ".join(' │ ',map { "%-".$_."s" } @colwidth_wrapped)." │";
   
   print $hor_rule_upper."\n";
   my @hvariables=map { "?".$_ } @{$variables_pary};
   format_row($format,\@colwidth_wrapped,\@hvariables);
   print $hor_rule_middle."\n";
   map { format_row($format,\@colwidth_wrapped,$_) } @{$rows_pary};
   print $hor_rule_lower."\n";
   # Total:
   print @{$rows_pary}." result".(@{$rows_pary}>1?"s":"")."\n";
}

# vim: set filetype=perl :

__END__

=pod

=encoding utf-8

=head1 NAME

srx2text

=head1 USAGE

srx2text [FILES...]

=head1 SYNOPSIS

Reads FILES... or standard input, that must be a well-formed srx file
(sparql-results+xml), see L<http://www.w3.org/TR/rdf-sparql-query/>,
and outputs a table in text format.

The common prefixes are used.

=head1 OPTIONS

=over 4

=item -h, -?, --help

Show this help and exit

=item -v, --version

Show version and exit

=item --fit-to-terminal, --nofit-to-terminal

Used if you pipe the output though less or through tee you'll probably want to
fit the table to terminal's width (default is --fit-to-terminal if output is
terminal)

=item --iri, --noiri

Show the URI as IRI (default is --iri)

=item --width W, -w W

Impose width to be W

=back

=head1 LICENSE

A very permissive one!

=head1 VERSION

0.1.12

=head1 AUTHOR

Gniourf - L<gniourfgniourf@gmail.com>

=cut

