#!/bin/bash

# Funny: it's 100% pure Bash, except the curl command (of course).

shopt -s extglob

host_default=http://localhost
port_default=3020
path_default=/sparql/

script_version=0.2.3
script_name=query-sparql

version() {
   printf "%s v%s\n" "$script_name" "$script_version"
}

help() {
   local help_ary
   mapfile help_ary <<EOF
Run a SPARQL query on a SPARQL endpoint, using curl

Usage:
   $script_name [OPTIONS] [file]

The file (or standard input if none specified) contains the sparql query.

OPTIONS:
   -h hostname       Use host hostname
   -p port           Use port port
   --path path       Use path path
   --loud            Remove curl's -sS option
   --no-silent       Same as --loud
   --help            Print this help and exit
   -?                Same as --help
   --version         Print version and exit
   -v                Same as --version
   --curlopt copt    Pass copt as an option to curl
   --show            Show query, host, port and path, but don't query endpoint

Default values:

host: $host_default
port: $port_default
path: $path_default

DATE:    2014-05-11
VERSION: $script_version
AUTHOR:  Gniourf, gniourfgniourf@gmail.com
LICENSE: A very permissive one!

INLINED OPTIONS: a cool feature of $script_name is that the options can also be
passed from inside the query file as follows: the file is grep'd over the regex
'^###-.' and the corresponding line is used as arguments. E.g., your file can contain

###-h dbpedia.org
###-p 80
###--curlopt -i

and then it's like running:

$script_name -h dbpedia.org -p 80 --curlopt -i file_no_inline

where file_no_inline is like file (the corresponding lines are not removed).
The advantage of this is to be able to use the query file with a shebang
#!/usr/local/bin/$script_name (and it didn't make the code much more
difficult).

Warning: this script is in an instable state; the options, interface, default
values and script name are subject to change in a near future (or not).
EOF
   printf '%s' "${help_ary[@]}"
}

die() {
   (($#)) && printf >&2 "%s\n" "$@"
   exit 1
}

get_option_gen() {
   local id=$1 var=$2
   shift 2
   if [[ $1 = $id ]]; then
      declare -g "$var=$2"
      shift_arg=2
   elif [[ $1 = $id=* ]]; then
      declare -g "$var=${1#"$id"=}"
      shift_arg=1
   else
      declare -g "$var=${1#"$id"}"
      shift_arg=1
   fi
}

get_option() {
   case $1 in
      (-p*) get_option_gen -p port "$@" ;;
      (-h*) get_option_gen -h host "$@" ;;
      (--path*) get_option_gen --path path "$@" ;;
      (--curlopt*) get_option_gen --curlopt copt "$@" ; curloptions+=( "$copt" ) ;;
      (--help|'-?') help ; exit 0 ;;
      (--version|-v) version ; exit 0 ;;
      (--loud|--no-silent) unset silent; shift_arg=1 ;;
      (--show) ((show=1)); shift_arg=1 ;;
      (-?) die "Unrecognized option $1" ;;
      (--) shift ;&
      (*) break_loop=1 ;;
   esac
}

silent=-sS
host=$host_default
port=$port_default
path=$path_default
show=0
curloptions=()
break_loop=0
while (($#)); do
   get_option "$@"
   ((break_loop)) && break
   shift "$shift_arg"
done

(($#>1)) && die "At most one non-option argument allowed"

# Slurp file in memory
if [[ -n $1 && $1 != - ]]; then
   exec < "$1" || die
fi
mapfile -t file_ary

# Get options from file (now in file_ary), if any
break_loop=0
((n_file_ary=${#file_ary[@]}))
for ((i=0;i<n_file_ary;++i)); do
   l=${file_ary[i]}
   [[ $l = '#'* || $l = *([[:blank:]]) || $l = '' ]] && unset file_ary[i]
   [[ $l = '###'-+([-[:alnum:]])* ]] || continue
   if ((!break_loop)); then
      read -r opt var <<< "${l#"###"}"
      get_option "$opt" "$var"
   fi
done

[[ $silent ]] && curloptions=( "$silent" "${curloptions[@]}" )

if ((show)); then
   fd=<(:)
   printf '%s\n' "curl \"${curloptions[@]}\" --data-urlencode query@$fd -- \"$host:$port$path\""
   printf '%s\n' "${file_ary[@]}"
   printf '%s\n' "(Query has not been sent)"
else
   curl "${curloptions[@]}" --data-urlencode "query@"<(printf '%s\n' "${file_ary[@]}") -- "$host:$port$path"
fi

