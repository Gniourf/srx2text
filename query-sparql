#!/bin/bash

host_default=http://localhost
port_default=3020
path_default=/sparql/

script_version=0.1
script_name=query-sparql

version() {
   printf "%s v%s\n" "$script_name" "$script_version"
}

help() {
   cat <<EOF
Run a SPARQL query on a SPARQL endpoint, using curl

Usage:
   $script_name [OPTIONS] [file]

The file (or standard input if none specified) contains the sparql query.

OPTIONS:
   -h hostname       Use host hostname
   -p port           Use port port
   --path path       Use path path
   --loud            Remove curl's -sS option
   --no-silent       Same as --loud
   --help            Print this help and exit
   -?                Same as --help
   --version         Print version and exit
   -v                Same as --version
   --curlopt copt    Pass copt as an option to curl

Default values:

host: $host_default
port: $port_default
path: $path_default

DATE:    2014-05-11
VERSION: $script_version
AUTHOR:  Gniourf, gniourfgniourf@gmail.com
LICENSE: A very permissive one!

INLINED OPTIONS: a cool feature of $script_name is that the options can also be
passed from inside the query file as follows: the file is grep'd over the regex
'^###-.' and the corresponding line is used as arguments. E.g., your file can contain

###-h dbpedia.org
###-p 80
###--curlopt -i

and then it's like running:

$script_name -h dbpedia.org -p 80 --curlopt -i file_no_inline

where file_no_inline is like file (the corresponding lines are not removed).
The advantage of this is to be able to use the query file with a shebang
#!/usr/local/bin/$script_name (and it didn't make the code much more
difficult).

Warning: this script is in an instable state; the options, interface, default
values and script name are subject to change in a near future (or not).
EOF
}

die() {
   printf >&2 "%s\n" "$@"
   exit 1
}

onExit() {
   [[ -n $tmp_file ]] && rm "$tmp_file"
}

get_option_gen() {
   local id=$1 var=$2
   shift 2
   if [[ $1 = $id ]]; then
      declare -g "$var=$2"
      shift_arg=2
   elif [[ $1 = $id=* ]]; then
      declare -g "$var=${1#"$id"=}"
      shift_arg=1
   else
      declare -g "$var=${1#"$id"}"
      shift_arg=1
   fi
}

get_option() {
   case $1 in
      (-p*) get_option_gen -p port "$@" ;;
      (-h*) get_option_gen -h host "$@" ;;
      (--path*) get_option_gen --path path "$@" ;;
      (--curlopt*) get_option_gen --curlopt copt "$@" ; curloptions+=( "$copt" ) ;;
      (--help|'-?') help ; exit 0 ;;
      (--version|-v) version ; exit 0 ;;
      (--loud|--no-silent) silent=; shift_arg=1 ;;
      (-*) die "Unrecognized option $1" ;;
      (--) shift ;&
      (*) break_loop=1 ;;
   esac
}

silent=-sS
host=$host_default
port=$port_default
path=$path_default
curloptions=()
break_loop=0
while (($#)); do
   get_option "$@"
   ((break_loop)) && break
   shift "$shift_arg"
done

(($#>1)) && die "At most one non-option argument allowed"

file=${1:--}
if [[ $file = - ]]; then
   # We'll make a tmp file in this case, as the file needs to be read twice
   trap onExit EXIT
   tmp_file=$(mktemp --tmpdir "$script_name-tmp.XXXXXXXXXX") || die "Couldn't create tmp file"
   cat > "$tmp_file"
   file=$tmp_file
fi

if [[ ! -f $file ]]; then
   die "File \`$file' not found"
elif [[ ! -r $file ]]; then
   die "Can't open file \`$file' for reading"
fi

# Get options from inside file (if any)
break_loop=0
while read -r opt arg; do
   get_option "$opt" "$arg"
   ((break_loop)) && break
done < <(sed -n 's/^###\(-.\)/\1/p' "$file")

[[ $silent ]] && curloptions=( "$silent" "${curloptions[@]}" )

curl "${curloptions[@]}" --data-urlencode "query@$file" -- "$host:$port$path"

