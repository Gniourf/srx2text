#!/bin/bash

shopt -s extglob

host_default=http://localhost
port_default=3020
path_default=/sparql/

script_version=0.3
script_name=query-sparql

declare -A options=(
   [silent]=-sS
   [host]=$host_default
   [port]=$port_default
   [path]=$path_default
   [show]=0
)

version() {
   printf "%s v%s\n" "$script_name" "$script_version"
}

help() {
   local help_ary
   mapfile help_ary <<EOF
Run a SPARQL query on a SPARQL endpoint, using curl

Usage:
   $script_name [OPTIONS] [file]

The file (or standard input if none specified) contains the sparql query.

OPTIONS:
   -h hostname       Use host hostname
   -p port           Use port port
   --path path       Use path path
   --loud            Remove curl's -sS option
   --no-silent       Same as --loud
   --help            Print this help and exit
   -?                Same as --help
   --version         Print version and exit
   -v                Same as --version
   --curlopt copt    Pass copt as an option to curl
   --show            Show query, host, port and path, but don't query endpoint
                     (default off)
   --dry-run         Same as --show

Note: the options may appear after the argument(s). At most one argument
allowed.

Default values:

host: $host_default
port: $port_default
path: $path_default

DATE:    2014-05-11
VERSION: $script_version
AUTHOR:  Gniourf, gniourfgniourf@gmail.com
LICENSE: A very permissive one!

INLINED OPTIONS: a cool feature of $script_name is that the options can also be
passed from inside the query file as follows: the file is grep'd over the regex
'^###-.' and the corresponding line is used as arguments. E.g., your file can
contain

###-h dbpedia.org
###-p 80
###--curlopt -i

and then it's like running:

$script_name -h dbpedia.org -p 80 --curlopt -i file_no_inline

where file_no_inline is like file (the corresponding lines are not removed).
The advantage of this is to be able to use the query file with a shebang
#!/usr/local/bin/$script_name (and it didn't make the code much more
difficult).

Funny note: this script is 100% pure Bash (except for the curl command, of
course).
EOF
   printf '%s' "${help_ary[@]}"
}

die() {
   (($#)) && printf >&2 "%s\n" "$@"
   exit 1
}

get_option_gen() {
   local id=$1 var=$2
   shift 2
   if [[ $1 = $id ]]; then
      declare -g options["$var"]="$2"
      shift_arg=2
   elif [[ $1 = $id=* ]]; then
      declare -g options["$var"]=${1#"$id="}
      shift_arg=1
   else
      declare -g options["$var"]="${1#"$id"}"
      shift_arg=1
   fi
}

argslist=()
get_option() {
   shift_arg=0
   case $1 in
      (-p*) get_option_gen -p port "$@" ;;
      (-h*) get_option_gen -h host "$@" ;;
      (--path*) get_option_gen --path path "$@" ;;
      (--curlopt*) get_option_gen --curlopt copt "$@" ; curloptions+=( "$copt" ) ;;
      (--help|'-?') help ; exit 0 ;;
      (--version|-v) version ; exit 0 ;;
      (--loud|--no-silent) unset options[silent]; shift_arg=1 ;;
      (--show|--dry-run) options[show]=1; shift_arg=1 ;;
      (-?) die "Unrecognized option $1" ;;
      (--) shift_arg=1; break_loop=1 ;;
      (*) shift_arg=1; argslist+=( "$1" ) ;;
   esac
}

curloptions=()
break_loop=0
while (($#)); do
   get_option "$@"
   ((break_loop)) && break
   shift "$shift_arg"
done
set -- "${argslist[@]}" "$@"

(($#>1)) && die "At most one non-option argument allowed"

# Slurp file in memory
if [[ -n $1 && $1 != - ]]; then
   exec < "$1" || die
fi
mapfile -t file_ary

# Get options from file (now in file_ary), if any
break_loop=0
((n_file_ary=${#file_ary[@]}))
for ((i=0;i<n_file_ary;++i)); do
   l=${file_ary[i]}
   [[ $l = '#'* || $l = *([[:blank:]]) || $l = '' ]] && unset file_ary[i]
   [[ $l = '###'-+([-[:alnum:]])* ]] || continue
   if ((!break_loop)); then
      read -r opt var <<< "${l#"###"}"
      get_option "$opt" "$var"
   fi
done

[[ ${options[silent]} ]] && curloptions=( "${options[silent]}" "${curloptions[@]}" )

# Dirty hack to _really_ show curl command without executing it
command_not_found_handle() {
   if((${options[show]})); then
      local IFS=' ' command=() idx=0 c
      for c; do printf -v command[++idx] '%q' "$c"; done
      printf "%s\n" "${command[*]}"
   else
      printf "The command %s could not be located. Please install it, or add its parent directory to your PATH variable\n" "$1"
   fi
}
if ((${options[show]})); then
   hash -r
   PATH=/dev/fd
fi

curl "${curloptions[@]}" --data-urlencode "query@"<(printf '%s\n' "${file_ary[@]}") -- "${options[host]}:${options[port]}${options[path]}"

if ((${options[show]})); then
   printf '%s\n' "${file_ary[@]}"
   printf '%s\n' "(No queries have been sent)"
fi

